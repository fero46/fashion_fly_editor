"use_strict"

angular.module("ffe").factory 'Settings', ($http) ->
  config:
    options: null

angular.module("ffe").factory 'Collection', ($http, Item) ->
  collection:
    title: null
    price: null

  price: ->
    items = Item.all()
    price = 0
    $.each items, (key, value) ->
      price += parseFloat(items[key]["price"])
    price

angular.module("ffe").factory 'Item', ($http) ->
  items: {}

  #helper
  itemsAsArray: ->
    self = @
    allItems = []
    $.each @items, (key, value) ->
#      self.items[key]['item_id'] = self.items[key]['id']
      delete self.items[key]["id"]
      allItems.push self.items[key]
    allItems

  create: (scope) ->
    # we pass in controller scope for calling callback
    self = @
    self.scope = scope

    url = window.location.origin + window.location.pathname + '/collections'

    data =
      collection:
        title: scope.collection.title
        collection_items_attributes: @itemsAsArray()

    # add config to data
    if scope.settings?
      data.redirect_url = scope.settings.config.collection.redirect_url

      # tbd: build items in rails instead, get rid of this bullshit
      options = {}
      values  = $('input[name^=options]')
      $.each values, (idx) =>
        item = $(values[idx])
        name = item.attr("name")
        name = name.replace("options[", "")
        name = name.replace("]","")
        options[name] = item.val()
      data.options = options

    $http(
      method: 'POST'
      url: url
      data: data
      dataType: 'JSON'
    ).success (data, status, headers, config) ->
      scope.collectionSuccessCallback(data, status) if self.scope?

    .error (data, status, headers, config) ->
      scope.collectionErrorCallback(data, status) if self.scope?

  get: (key) ->
    @items[key]

  add: (key, item) ->
    @update key, item

  update: (key, item) ->
    @items[key] = item

  delete: (key) ->
    delete @items[key]

  all: ->
    @items

  select: (key) ->
    @selected = @items[key]

angular.module("ffe").factory 'Search', ($resource, $rootScope) ->
  class Search
    constructor: () ->
      @service = $resource("<%= FashionFlyEditor::Engine.configuration.products_endpoint %>/:id",
        { id: '@id'},
        { query: { method: "GET", isArray: false,  } })

    all: (params = {}) ->
      @service.query(params, (data) ->
        $rootScope.$broadcast("search_loaded", data)
      )

angular.module("ffe").factory 'Category', ($resource, $rootScope) ->
  class Category
    constructor: (categoryId) ->
      @service = $resource("<%= FashionFlyEditor::Engine.configuration.categories_endpoint %>/:id"
        { id: '@id' },
        { query: { method: "GET", isArray: false,  } })

    create: (attrs) ->
      new @service(category: attrs).$save (category) ->
        attrs.id = category.id
      attrs

    get: (id) ->
      @service.get(id: id, (data) ->
        $rootScope.$broadcast("category_loaded", data)
      )

    all: (cb) ->
      self = @

      @service.query( (data) ->
        self.firstCategoryId = data.categories[0].id
        self.brands     = data.categories.brands
        self.options    = data.options if data.options?
        self.scope      = data.scope if data.scope?
        self.collection = data.collection if data.collection?

        $rootScope.$broadcast("category_loaded", id: self.firstCategoryId)
      )

    firstCategoryId: ->
      @firstCategoryId

    brands: ->
      @brands